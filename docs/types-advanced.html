<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta charset="UTF-8" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="stylesheet" type="text/css" href="style-web.css" />
<link rel="next" title="オプションを知り己のコードを知れば百戦危うからず" href="tsc-options.html"><link rel="prev" title="型は便利だ楽しいな" href="types-basic.html">  <meta name="generator" content="Re:VIEW" />
  <title>アドバンスド型戦略 | Revised TypeScript in Definitelyland</title>
</head>
<body>
  <div class="book">
    <nav class="side-content">
      <h1>Revised TypeScript in Definitelyland</h1>
      <ul class="book-toc">
<li><a href="index.html">TOP</a></li>
<li><a href="./index.html">Revised 型の国のTypeScript</a></li>
<li><a href="./prepared-to-typescript.html">1 戦闘準備だ！TypeScript！</a></li>
<li><a href="./typescript-basic.html">2 TypeScriptの基本</a></li>
<li><a href="./types-basic.html">3 型は便利だ楽しいな</a></li>
<li><a href="./types-advanced.html">4 アドバンスド型戦略</a></li>
<li><a href="./tsc-options.html">5 オプションを知り己のコードを知れば百戦危うからず</a></li>
<li><a href="./definition-file.html">6 JS資産と型定義ファイル</a></li>
</ul>
      <p class="review-signature">powered by <a href="http://reviewml.org/">Re:VIEW</a></p>
    </nav>
    <div class="book-body">
      <header>
      </header>
      <div class="book-page">
        <h1 id="types-advanced"><a id="h4"></a><span class="secno">第4章　</span>アドバンスド型戦略</h1>
<p>型のうち、難しいけど便利な話や、あまり関わりたくないけど実用上たまにお世話になる内容を解説していきます。タプル型（tuple types）や直和型（union types）についての解説もありますよ！なお、普段書くコードではこの章で出てくる内容をなるべく使わずに済む設計こそよい設計だと筆者は考えています<a id="fnb-bad-code" href="#fn-bad-code" class="noteref" epub:type="noteref">*1</a>。</p>
<p>TypeScriptでコードを書く中で、JavaScriptで書かれたコードを型定義ファイルを介して扱う場面があります。そういったときに本章の内容が活きてくる場面があるでしょう。しかし、本章で書かれた内容を活かさないと上手く扱えないJavaScriptコードは、元々の品質が微妙なコードだと考えてよいでしょう。</p>
<div class="footnote" epub:type="footnote" id="fn-bad-code"><p class="footnote">[*1] 本章で触れる機能を使うほうがよい場合もあります。たとえば構文木の構築・分解時などです。自分の用途に本当にそれが必要かはよくよく考えてみてください</p></div>

<h2 id="union-types"><a id="h4-1"></a><span class="secno">4.1　</span>直和型（Union Types）</h2>
<p>はい、皆様待望の機能でございます。&quot;名前を言ってはいけないあの界隈&quot;がよく使う用語を使って解説しないといけないのでビクビクですね。</p>
<p>一番最初に書いておくけど<strong>TypeScriptのコード書くときに積極的に使うものじゃあないぞ！！</strong>という感じなんですが、<code class="inline-code tt">--strictNullChecks</code>オプションを使う場合に避けて通れない要素であるためしっかり覚えましょう。</p>
<p>では解説していきましょう。union typesはいわゆる直和型です。たとえば<code class="inline-code tt">string | number | boolean</code>という型注釈があった場合、この変数の値はstringか、numberか、booleanかのどれか！ということを表します。</p>
<p>なんのために直和型がTypeScriptに導入されたかというと、まずは既存JavaScriptによりよい型定義を与えるためでしょう。そしてnullやundefined、string literal typesなどTypeScriptの中でも適用領域が広がっています。JavaScriptという現実と安全な世界を構築するTypeScriptの橋渡しを上手にしてくれる機能といえます。</p>
<p>ちなみに自分でTypeScriptコード書いてるときにあまり欲しくなる機能ではありません。</p>
<p>まずは簡単な例から見ていきましょう（リスト4.1）。</p>
<div class="caption-code">
<p class="caption">リスト4.1: 型A | 型B でAかBのどちらかを表す</p>
<pre class="list language-ts">let a: string | boolean | undefined;
// string | boolean なので次はオッケー！
a = &quot;str&quot;;
a = true;
// number はアカン。
// error TS2322: Type 'number' is not assignable
//   to type 'string | boolean | undefined'.
// a = 1;

// b1 と b2 を合体させてみよう
let b1: string | boolean | undefined;
let b2: boolean | number | undefined;
// c の型は string | number | boolean | undefined となる
let c: typeof b1 | typeof b2;

export { b1, b2, c }
</pre>
</div>
<p>型注釈を書く際に複数の型を｜で区切って書けます。既存のJavaScriptライブラリだとこういった、返り値の型が複数ある困った関数がかなりあります。あとは普通にTypeScriptを書いているときでもSyntaxTreeとかをコードから構築するときにはあったほうが便利かもしれません。</p>
<p>ご覧のとおり、union types中の型の順番とかは関係ない（交換可能）し、union typesのunion typesなどは合体させてひとつのunion typesにできます。</p>
<p>TypeScriptを自然に書いていて、union typesを目にする機会は3種類あります。|| 演算子を使ったとき、条件（三項）演算子を使ったとき、配列リテラルを使ったときです（リスト4.2）。</p>
<div class="caption-code">
<p class="caption">リスト4.2: こういうときは目にしますね</p>
<pre class="list language-ts">// and の型は string | boolean
let and = &quot;str&quot; || true;
// cond の型は number | string
let cond = true ? 1 : &quot;str&quot;;
// array の型は (number | boolean | string)[]
let array = [1, true, &quot;str&quot;];

export { and, cond, array }
</pre>
</div>
<p>一番よくお目にかかるのは配列リテラルでしょうか。TypeScriptのベストプラクティスとして1つの配列で複数の型の値を扱わないほうが堅牢なコードになるため、きれいなコードを書いている限りはあまり見ないかもしれません。</p>
<p>型注釈として関数を与えるときは記法にちょっと気をつけないとコンパイルエラーになります（リスト4.3）。</p>
<div class="caption-code">
<p class="caption">リスト4.3: 型名をカッコで囲うんです？</p>
<pre class="list language-ts">// 引数無しの返り値stringな関数 な型注釈
let func: () =&gt; string;

// 素直に考えるとこう書けてもいいっしょ！でもダメ！
// let a: () =&gt; string | () =&gt; boolean;

// 型名をカッコでくくる必要がある。これならOK
let b: (() =&gt; string) | (() =&gt; boolean);
// もしくはオブジェクト型リテラル使う
let c: { (): string; } | { (): boolean; };

// union typesじゃないときでも使えるけど見づらいな！
let d: (() =&gt; string);

export { func, b, c, d }
</pre>
</div>
<p>読みづらいコードになってしまいました。型にも適切な名前をつけることの重要さが偲ばれます。</p>
<p>union typesな値を使うときは、型アサーションを使うこともできますがなるべくなら避けましょう（リスト4.4）。</p>
<div class="caption-code">
<p class="caption">リスト4.4: 一応使えるよ こうすれば</p>
<pre class="list language-ts">// 注意！ここでやってるやり方よりもtype guardsを使うんだ…！！
// 型アサーションは悪い。常に悪い。なるべく使わないこと。

let obj: string | number | Date = null as any;

// string 扱いしてみる
(obj as string).charAt(0);

// number 扱いしてみる
(obj as number).toFixed(2);

// Date 扱いしてみる
(obj as Date).getTime();

// 値の集合に含まれない型にしてみると普通に怒られる
// error TS2352: Type 'string | number | Date' cannot be converted to type 'RegExp'.
//   Type 'Date' is not comparable to type 'RegExp'.
//     Property 'exec' is missing in type 'Date'.
// (&lt;RegExp&gt;obj).test(&quot;test&quot;);

export { }
</pre>
</div>
<p>union typesを相手にする場合は、次に説明する「4.2 型の番人（Type Guards）」を使いましょう。話はそれからだ！</p>

<h2 id="type-guards"><a id="h4-2"></a><span class="secno">4.2　</span>型の番人（Type Guards）</h2>
<p>type guardsは、union typesが導入されたことで変数の型が一意ではなくなってしまったため、それを自然に解決するために導入された仕組みです。type guardsは&quot;変数Aが○○という条件を満たすとき、変数Aの型は××である&quot;というルールを用いて、ガード（番人となる条件式など）の後の文脈で変数の型を××に狭めることができます。</p>

<h3 id="control-flow-based-type-analysis"><a id="h4-2-1"></a>処理フローに基づく型の解析（Control Flow Based Type Analysis）</h3>
<p>さて、トップバッターがいきなり公式にtype guardsの一員なのか怪しいのですがいってみましょう。名前が長いですが、要するに普通にコードを書いていった時に、値の型を判別するコードは分岐にしたがって変数の型が絞り込まれるというものです。</p>
<p>例を見ていきましょう。TypeScriptを書いていて一番対処を迫られるunion typesのパターンはおそらく<code class="inline-code tt">T | undefined</code>のような、何か＋<code class="inline-code tt">undefined</code>の形式でしょう。if文を用いてundefinedの値について対処してみます（リスト4.5）。</p>
<div class="caption-code">
<p class="caption">リスト4.5: undefinedの可能性を潰す</p>
<pre class="list language-ts">function upperA(word?: string) {
  // wordは省略可能引数なので string | undefined
  // ここでwordをいきなり使おうとするとエラーになる
  // Object is possibly 'undefined'.
  // word.toUpperCase();

  if (word == null) { // word が null か undefined の時
    // undefinedの可能性をstringで上書き！
    word = &quot;TypeScript&quot;;
  }

  // undefinedの可能性を潰したのでこの時点でwordはstring確定！
  console.log(word.toUpperCase());
}

function upperB(word?: string) {
  // 別解：JSで || 演算子は最初にtruthyになった値を返す
  // ので、undefined（falsy）な時は &quot;TypeScript&quot; で上書きされる
  word = word || &quot;TypeScript&quot;;

  // undefinedの可能性を潰したのでこの時点でwordはstring確定！
  console.log(word.toUpperCase());
}

function upperC(word = &quot;TypeScript&quot;) {
  // TypeScript的に一番素直なパターン
  console.log(word.toUpperCase());
}

export { upperA, upperB, upperC }
</pre>
</div>
<p>もう一例見てみましょう。引数に<code class="inline-code tt">string</code>と<code class="inline-code tt">string[]</code>を取り、これを<code class="inline-code tt">string[]</code>に統一して利用します（リスト4.6）。</p>
<div class="caption-code">
<p class="caption">リスト4.6: 変数の型を統一していく</p>
<pre class="list language-ts">function upperAll(words: string | string[]) {
  if (typeof words === &quot;string&quot;) {
    // string なら string[] に変換する
    words = [words];
  }

  // この時点ではwordsはstring[]に揃えられる
  return words.map(word =&gt; word.toUpperCase());
}

console.log(upperAll(&quot;TypeScript&quot;));
console.log(upperAll([&quot;TypeScript&quot;, &quot;JavaScript&quot;]));

export { }
</pre>
</div>
<p>変数のプロパティに対してもtype guardsは利用可能です（リスト4.7）。コンパイラの実装を想像すると、なにげに大変そうなことをやっていて思わず感心してしまいます。</p>
<div class="caption-code">
<p class="caption">リスト4.7: 変数のプロパティも絞り込める</p>
<pre class="list language-ts">interface Foo {
  value: number | string;
}

let foo: Foo = {
  value: &quot;TypeScript&quot;,
};

// number | string では toUpperCase があるか確定できない
// error TS2339: Property 'toUpperCase' does not exist on type 'number | string'.
// foo.value.toUpperCase();

// 変数直だけではなくて、変数のプロパティでもtype guardsが使える
if (typeof foo.value === &quot;string&quot;) {
  // ここでは foo.value は string に絞りこまれている！一時変数いらない！
  foo.value.toUpperCase();
}

export { }
</pre>
</div>
<p>最後に、関数が絡んだ場合の例を見ておきます（リスト4.8）。関数の内側と外側では、処理フローは別世界です。関数はいつ実行されるかわからないため、変数の再代入が可能な場合、関数の内側で別途絞込みを行う必要があります。一方、constを使うと変数の値を変えることができないため、この問題を回避できる場合があります。</p>
<div class="caption-code">
<p class="caption">リスト4.8: 関数の外側でのフローは内側では関係ない</p>
<pre class="list language-ts">let v1: string | number;
if (typeof v1 === &quot;string&quot;) {
  let f = () =&gt; {
    // これはエラーになる！
    // プログラムの字面的にはstringに確定されていそう…
    // しかし、関数はいつ実行されるかわからない
    // error TS2339: Property 'toUpperCase'
    //   does not exist on type 'string | number'.
    console.log(v1.toUpperCase());
  };
  // ここではvはまだstring
  f();

  // ここでvがnumberに！
  v1 = 1;
  f();
}

// letではなくてconstを使うと…
const v2: string | number = null as any;
if (typeof v2 === &quot;string&quot;) {
  let f = () =&gt; {
    // v2の中身が入れ替えられる可能性はないのでエラーにならない
    console.log(v2.toUpperCase());
  };
  f();

  // constなので再代入しようとするとエラーになる
  // error TS2450: Left-hand side of assignment expression
  //   cannot be a constant or a read-only property.
  v2 = 1;
}
</pre>
</div>
<p>さて、次項意向でどういう処理が絞り込みに繋がるのかの例を見ていきます。</p>

<h3 id="typeof-type-guards"><a id="h4-2-2"></a>typeofによるType Guards</h3>
<p>JavaScriptの<code class="inline-code tt">typeof</code>は指定した値がどういう性質のオブジェクトかを調べ、文字列で返す演算子です。ECMAScript 5の範囲では、変換ルールは次のとおりです。</p>
<ul>
<li>string のときは&quot;string&quot;を返す</li>
<li>boolean のときは&quot;boolean&quot;を返す</li>
<li>number のときは&quot;number&quot;を返す</li>
<li>undefined のときは&quot;undefined&quot;を返す</li>
<li>関数として呼び出し可能な場合は&quot;function&quot;を返す</li>
<li>それ以外の場合（nullを含む！）は&quot;object&quot;を返す</li>
</ul>
<p>これを利用して、変数の型を狭めます。</p>
<p>一番簡単な使い方から見ていきましょう（リスト4.9）。TypeScriptのtype guardsではtypeofの結果がstring、boolean、numberの場合、その型に絞り込むことができます。</p>
<div class="caption-code">
<p class="caption">リスト4.9: 実際の型がわからないなら調べるしかないじゃない！</p>
<pre class="list language-ts">let obj: number | string = null as any;
if (typeof obj === &quot;string&quot;) {
  // ここでは string と確定されている！
  obj.charAt(0);
} else {
  // ここでは消去法で number と確定されている！
  obj.toFixed(2);
}

export { }
</pre>
</div>
<p>変数objをtypeofで調べたときに値がstringだったので、変数objの型はstringである、という具合に絞りこまれています。</p>
<p>もう一例見てみましょう。リスト4.10では、anyやnumberと指定された変数をtype guardsでstringに絞り込んでいます。</p>
<div class="caption-code">
<p class="caption">リスト4.10: 変なコードを書くとコンパイラが教えてくれる</p>
<pre class="list language-ts">let objA: any;
if (typeof objA === &quot;string&quot;) {
  // ここでは string と確定されている！
  // number にしか存在しないメソッドを呼ぶとコンパイルエラー！
  // error TS2339: Property 'toFixed' does not exist on type 'string'.
  objA.toFixed(0);
}

let objB: number = 1;
if (typeof objB === &quot;string&quot;) {
  // &quot;ありえない&quot; パターンだとnever型になり怒られる
  // error TS2339: Property 'toFixed' does not exist on type 'never'.
  objB.toFixed(0);
}
</pre>
</div>
<p>この操作を行うと&quot;ありえない&quot;ことを表すnever型になるため、<code class="inline-code tt">obj.toFixed(0)</code>というstringには存在しないメソッドの呼び出しはコンパイルエラーとなります。</p>
<p>うーん、便利ですね。変数に指定した型どおりの値が入ってくるのが健全なので、コンパイル時にミスが発見されるのは嬉しいことです。</p>

<h3 id="instanceof-type-guards"><a id="h4-2-3"></a>instanceofによるType Guards</h3>
<p>typeofでしかtype guardsが使えないと辛いので、instanceofを使ったtype guardsも、もちろんあります。</p>
<p>JavaScriptにおけるinstanceofは、ある値が指定した関数のインスタンスであるかを調べる演算子です。プロトタイプチェーンも遡ってみていくので、親子関係にある場合もインスタンスかどうかを調べることができます。</p>
<p>動作例を確認してみましょう（リスト4.11）。</p>
<div class="caption-code">
<p class="caption">リスト4.11: instanceof の挙動</p>
<pre class="list language-ts">class Base {
}

class InheritA extends Base {
}
class InheritB extends Base {
}

let obj = new InheritA();

// trueと表示される
console.log(obj instanceof Base);
// trueと表示される
console.log(obj instanceof InheritA);
// falseと表示される
console.log(obj instanceof InheritB);

// 無理矢理親を差し替える！
InheritA.prototype = new InheritB();
obj = new InheritA();
// trueと表示される
console.log(obj instanceof InheritB);

export { }
</pre>
</div>
<p>オブジェクトのprototypeと一致するか順番どおり見ていくだけですね。</p>
<p>instanceofで型を絞り込みます（リスト4.12）。</p>
<div class="caption-code">
<p class="caption">リスト4.12: instanceofの挙動</p>
<pre class="list language-ts">class A {
  str: string;
}
class B {
  num: number;
}
class C extends A {
  bool: boolean;
}

let obj: A | B | C = null as any;
if (obj instanceof A) {
  // ここでは A（含むC) と確定している
  obj.str;
  if (obj instanceof C) {
    // ここではCと確定している
    obj.bool;
  }
}

if (obj instanceof C) {
  // ここではCと確定している
  obj.bool;
} else {
  // ここではまだ A | B
  if (obj instanceof B) {
    // ここではBと確定している
    obj.num;
  } else {
    // ここではAと確定している
    obj.str;
  }
}

export { }
</pre>
</div>
<p>昔のTypeScriptと違って、instanceofのelse句でも型の絞り込みが行われます。挙動として納得感があり大変よいですね。</p>

<h3 id="user-defined-type-guards"><a id="h4-2-4"></a>ユーザ定義のType Guards（User-defined Type Guards）</h3>
<p>ユーザが定義した関数によって、ある値がなんの型なのかをTypeScriptコンパイラに教える方法があります（リスト4.13）。型判別用の関数を作成し、そこで返り値に<code class="inline-code tt">仮引数名 is 型名</code>という形式で判別結果を指定します。この書き方をした場合、返り値はbooleanでなければなりません。</p>
<div class="caption-code">
<p class="caption">リスト4.13: ユーザ定義のtype guards</p>
<pre class="list language-ts">class Sample {
  str: string;
}

// 構造的部分型！
let obj: Sample = {
  str: &quot;Hi!&quot;,
};

// 独自にSample型である事の判定を実装する
function isSample(s: Sample): s is Sample {
  if (!s) {
    return false;
  }
  // とりあえず、strプロパティがあって値がstringなら
  // Sample型に互換性あり！という基準にする
  return typeof s.str === &quot;string&quot;;
}

if (isSample(obj)) {
  console.log(obj.str);
}

export { }
</pre>
</div>
<p>面白い記法として、isの左辺にthisを用いることもできます（リスト4.14）。</p>
<div class="caption-code">
<p class="caption">リスト4.14: isの左辺にthisを使う</p>
<pre class="list language-ts">abstract class Node {
  isStringNode(): this is StringNode {
    return this instanceof StringNode;
  }
  isNumberNode(): this is NumberNode {
    return this instanceof NumberNode;
  }
}

class StringNode extends Node {
  constructor(public text: string) {
    super();
  }
}

class NumberNode extends Node {
  constructor(public value: number) {
    super();
  }
}

let nodes: Node[] = [new StringNode(&quot;TypeScript&quot;), new NumberNode(8)];
// TypeScript と 8 と表示される
nodes.forEach(n =&gt; {
  if (n.isStringNode()) {
    // n is StringNode!
    console.log(n.text);
  } else if (n.isNumberNode()) {
    // n is NumberNode!
    console.log(n.value);
  }
});

export { }
</pre>
</div>
<p>引数として渡された値の型名を明示する代わりに、thisの型を指定するわけです。これも利用する機会は少なさそうですが、ツリー状の構造を作るときなどに活躍しそうです。</p>

<h3 id="type-guards-and-logical-operators"><a id="h4-2-5"></a>Type Guardsと論理演算子</h3>
<p>type guardsは<code class="inline-code tt">&amp;&amp;</code>とか<code class="inline-code tt">||</code>とか<code class="inline-code tt">?</code>とか<code class="inline-code tt">!</code>とかの論理演算子にもちゃんと対応しています（リスト4.15）。</p>
<div class="caption-code">
<p class="caption">リスト4.15: ブール代数みたいな演算に対応してる</p>
<pre class="list language-ts">let obj: number | boolean | string = null as any;

// &amp;&amp;演算子で絞込み
typeof obj === &quot;string&quot; &amp;&amp; obj.charAt(0);
// 次のようなコードはエラーになる！
// error TS2339: Property 'charAt' does not exist on type 'number'.
// typeof obj === &quot;number&quot; &amp;&amp; obj.charAt(0);

// ||演算子でunion typesに
if (typeof obj === &quot;string&quot; || typeof obj === &quot;boolean&quot;) {
  // string | boolean に絞り込まれる
} else {
  // 消去法でnumber！
}

// 三項演算子は普通にif文と一緒の挙動
typeof obj === &quot;string&quot; ? obj.charAt(0) : obj;
// 次と等価
if (typeof obj === &quot;string&quot;) {
  obj.charAt(0);
} else {
  obj;
}

// 一応、否定演算子にも対応している
if (!(typeof obj !== &quot;string&quot;)) {
  // 否定の否定は普通にそのまんまstringだな！ちゃんと絞り込まれます
  obj.charAt(0);
}

export { }
</pre>
</div>
<p>あんまり使わないかもしれませんが、他の人がこの書き方を使った時に戸惑わぬよう頭の片隅にはとどめておいたほうがよいかもしれません。</p>

<h3 id="type-guards-weakpoint"><a id="h4-2-6"></a>Type Guardsの弱点</h3>
<p>type guardsは型システム上の仕組みだということを忘れてはいけません。JavaScriptの実行環境とは全く関係がないのです。</p>
<p>TypeScriptでは構造的部分型の仕組みにより、クラスが要求されている箇所に互換性のある別の値を代入できます。</p>
<p>その仕組みを使って、リスト4.16のようなコードが書けてしまいます。</p>
<div class="caption-code">
<p class="caption">リスト4.16: 構造的部分型とtype guards</p>
<pre class="list language-ts">class Sample {
  str: string;
}

// 構造的部分型！
let obj: Sample = {
  str: &quot;Hi!&quot;,
};

if (obj instanceof Sample) {
  // 型はSampleに絞られている しかし、絶対に到達しない
  // 現在のobjはSampleを親に持たない
  console.log(obj.str);
}

export { }
</pre>
</div>
<p>objはSampleを型として持ち、その値として互換性のあるオブジェクトリテラルを持っています。コンパイル後のJavaScriptコード（リスト4.17）を見ると、objの値がSampleクラスのインスタンスではないことが一目瞭然ですが、TypeScript上で見ると型を元に判別されていると勘違いしやすいことを頭の片隅においておきましょう。</p>
<div class="caption-code">
<p class="caption">リスト4.17: コンパイル後のJS</p>
<pre class="list language-js">&quot;use strict&quot;;
class Sample {
}
// 構造的部分型！
let obj = {
    str: &quot;Hi!&quot;,
};
if (obj instanceof Sample) {
    // 型はSampleに絞られている しかし、絶対に到達しない
    // 現在のobjはSampleを親に持たない
    console.log(obj.str);
}
</pre>
</div>
<p>これを回避する方法がいくつかあります。</p>
<p>ひとつ目は、ユーザ定義のtype guardsを使う方法。ふたつ目はprivateな要素をクラスに突っ込んでしまうことです（リスト4.18）。</p>
<div class="caption-code">
<p class="caption">リスト4.18: privateな要素があれば構造的部分型で値を偽造できない</p>
<pre class="list language-ts">class Sample {
  str: string;
  private _tmp: any;
}

// privateなインスタンス変数があるクラスのインスタンスは偽造できない！
// error TS2322: Type '{ _tmp: null; str: string; }' is not
//     assignable to type 'Sample'. Property '_tmp' is private
//     in type 'Sample' but not in type '{ _tmp: null; str: string; }'.
let obj: Sample = {
  str: &quot;Hi!&quot;,
  _tmp: null,
};
</pre>
</div>
<p>色々書きましたが、一番の解決策はunion typesやanyを多用せず、真っ当なコードを書けるよう設計することです。</p>

<h2 id="intersection-types"><a id="h4-3"></a><span class="secno">4.3　</span>交差型（Intersection Types）</h2>
<p>union typesに似た記法のintersection types（交差型）です。intersection typesは2つの型を合成し、1つの型にできます。union typesと違って利用頻度は低く、TypeScript的に使いたくなるシチュエーションもほとんどありません。</p>
<p>まずは例を見てみましょう。ある関数に渡したオブジェクトを拡張し、新しいプロパティやメソッドを生やします（リスト4.19）。</p>
<div class="caption-code">
<p class="caption">リスト4.19: 型を合成する</p>
<pre class="list language-ts">interface Storage {
  $save(): void;
}

function mixinStorage&lt;T&gt;(base: T): T &amp; Storage {
  let modified = base as any;
  modified.$save = () =&gt; {
    // めんどいので保存したフリ
    console.log(`データを保存しました！ ${JSON.stringify(base)}`);
  };

  return modified;
}

// 何の変哲もないオブジェクト
let base = {
  name: &quot;TypeScript&quot;,
};
// を、Storageを合成する関数に渡す
let obj = mixinStorage(base);

// baseに存在しないメソッドが呼べる！
// データを保存しました！ {&quot;name&quot;:&quot;TypeScript&quot;} と表示される
obj.$save();

// もちろん、baseにあったプロパティにもアクセスできる
obj.name = &quot;JavaScript&quot;;
// データを保存しました！ {&quot;name&quot;:&quot;JavaScript&quot;} と表示される
obj.$save();

export { }
</pre>
</div>
<p>intersection typesを使うと、型定義ファイルが書きやすくなる場合があります。例を見てみます（リスト4.20）。intersection typesを使わない書き方とintersection typesを使った書き方、どちらのほうが理解しやすいでしょうか？</p>
<div class="caption-code">
<p class="caption">リスト4.20: 型の合成で素直な定義を作る</p>
<pre class="list language-ts">// intersection typesを使わない書き方
declare namespace angular.resource1 {
  interface ResourceProvider {
    create&lt;T extends Resource&lt;any&gt;&gt;(): T;
  }

  interface Resource&lt;T&gt; {
    $insert(): T;
  }
  let $resource: ResourceProvider;
}
// 上の定義を使ってみる
namespace sample1 {
  interface Sample {
    str: string;
  }
  // SampleResourceという型を1つ無駄に作らねばならぬ
  // なぜこれで動くのか、トリックがわかるだろうか？
  interface SampleResource extends Sample, angular.resource1.Resource&lt;Sample&gt; { }

  let $obj = angular.resource1.$resource.create&lt;SampleResource&gt;();
  $obj.str = &quot;test&quot;;
  let obj = $obj.$insert();
  console.log(obj.str);
}

// intersection typesを使った書き方
declare namespace angular.resource2 {
  interface ResourceProvider {
    create&lt;T&gt;(): T &amp; Resource&lt;T&gt;;
  }

  interface Resource&lt;T&gt; {
    $insert(): T;
  }
  let $resource: ResourceProvider;
}
// 上の定義を使ってみる
namespace sample2 {
  interface Sample {
    str: string;
  }

  // 超簡単…！！
  let $obj = angular.resource2.$resource.create&lt;Sample&gt;();
  $obj.str = &quot;test&quot;;
  let obj = $obj.$insert();
  console.log(obj.str);
}

export { sample1, sample2 }
</pre>
</div>
<p>intersection typesを使いこなした書き方のほうが、圧倒的に謎が少なく素直に書けています。</p>

<h2 id="string-literal-types"><a id="h4-4"></a><span class="secno">4.4　</span>文字列リテラル型（String Literal Types）</h2>
<p>文字列リテラルを型として使える機能です。パッと読んだだけでは、意味がわからないですね。まずは例を見てみましょう（リスト4.21）。</p>
<div class="caption-code">
<p class="caption">リスト4.21: カードのスートを型として表す</p>
<pre class="list language-ts">// &quot;文字列&quot; が 型 です。値ではない！
let suit: &quot;Heart&quot; | &quot;Diamond&quot; | &quot;Club&quot; | &quot;Spade&quot;;

// OK
suit = &quot;Heart&quot;;
// NG suitの型に含まれていない
// error TS2322: Type '&quot;Joker&quot;' is not
//   assignable to type '&quot;Heart&quot; | &quot;Diamond&quot; | &quot;Club&quot; | &quot;Spade&quot;'.
// suit = &quot;Joker&quot;;

export { }
</pre>
</div>
<p>文字列が型というのは見慣れないとすごく気持ちが悪いですね。しかし、この機能はTypeScriptがJavaScriptの現実と折り合いをつける上で重要な役割があります。たとえば、DOMのaddEventListenerなどです。指定するイベント名によって、イベントリスナーの型が変わります（リスト4.22）。</p>
<div class="caption-code">
<p class="caption">リスト4.22: イベント名によって型が変わる</p>
<pre class="list language-ts">// lib.dom.d.ts から抜粋
// 第一引数で指定するイベントによってリスナーで得られるイベントの型が違う
interface HTMLBodyElement extends HTMLElement {
  addEventListener(
    type: &quot;change&quot;,
    listener: (this: this, ev: Event) =&gt; any,
    useCapture?: boolean): void;
  addEventListener(
    type: &quot;click&quot;,
    listener: (this: this, ev: MouseEvent) =&gt; any,
    useCapture?: boolean): void;
  addEventListener(
    type: &quot;keypress&quot;,
    listener: (this: this, ev: KeyboardEvent) =&gt; any,
    useCapture?: boolean): void;
  addEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    useCapture?: boolean): void;
}
</pre>
</div>
<p>これにより、自然にTypeScriptでコードを書くだけでリスナーで受け取れるイベントの型が自動的に適切なものに絞りこまれます。こんなものが必要になってしまうJavaScriptの複雑さよ…。</p>
<p>またunion typesと文字列リテラル型を組み合わせ、switchで条件分岐ができます（リスト4.23）。</p>
<div class="caption-code">
<p class="caption">リスト4.23: Union Typesはswitchでえこひいきされている</p>
<pre class="list language-ts">// 足し算
interface Add {
  type: &quot;add&quot;;
  left: Tree;
  right: Tree;
}
// 末端の値
interface Leaf {
  type: &quot;leaf&quot;;
  value: number;
}

type Tree = Add | Leaf;

// (10 + 3) + 5 を表現する
let node: Tree = {
  type: &quot;add&quot;,
  left: {
    type: &quot;add&quot;,
    left: { type: &quot;leaf&quot;, value: 10 },
    right: { type: &quot;leaf&quot;, value: 3 },
  },
  right: {
    type: &quot;leaf&quot;,
    value: 5,
  },
};

// 18 と表示される
console.log(calc(node));

function calc(root: Tree): number {
  // プロパティの値で型の絞込ができる！
  switch (root.type) {
    case &quot;leaf&quot;:
      // 型は Leaf で決定！
      return root.value;
    case &quot;add&quot;:
      // 型は Add で決定！
      return calc(root.left) + calc(root.right);
    default:
      throw new Error(&quot;unknown node&quot;);
  }
}

export { }
</pre>
</div>
<p>switch文によるtype guards（後述）はTypeScript 2.1.0からのサポートが予定されているので、現時点ではえこひいきされていますね。</p>
<p>なお、執筆時点でアンダース・ヘルスバーグ御大が<i>Number, enum, and boolean literal types</i>というpull requestを作成、作業しています<a id="fnb-primitive-literal-types" href="#fn-primitive-literal-types" class="noteref" epub:type="noteref">*2</a>。</p>
<div class="footnote" epub:type="footnote" id="fn-primitive-literal-types"><p class="footnote">[*2] <a href="https://github.com/Microsoft/TypeScript/pull/9407" class="link">https://github.com/Microsoft/TypeScript/pull/9407</a></p></div>

<h2 id="type-alias"><a id="h4-5"></a><span class="secno">4.5　</span>型の別名（Type Alias）</h2>
<p>最初に書いておきます。<strong>可能な限りtype aliasを使うな！interface使え！</strong>筆者はtype aliasの乱用を恐れています！</p>
<p>type aliasもunion typesの扱いを便利にするために導入された機能です。機能としてはただ単に型をひとまとまりにして、それに名前が付けられるだけです。それだけです。</p>
<p>type aliasは仕様上、interfaceと同じように利用できる場面もあります。ですが、基本的にtype aliasはinterfaceより機能が貧弱であるため、なるべく避けるべきです。</p>
<p>代表例を見てみましょう（リスト4.24）。</p>
<div class="caption-code">
<p class="caption">リスト4.24: 頻出するunion typesに名前をつける</p>
<pre class="list language-ts">type FooReturns = string | number | boolean;

interface Foo {
  bar(): FooReturns;
  buzz(): FooReturns;
  barbuzz(): FooReturns;
}
</pre>
</div>
<p>わかりやすいですね。1ヶ所変更すると、関連箇所がすべて更新されるのも便利です。</p>
<p>tuple typesに名前をつけることもできます（リスト4.25）。</p>
<div class="caption-code">
<p class="caption">リスト4.25: tuple typesに名前をつける</p>
<pre class="list language-ts">// tuple typesに名前をつける
type Point = [number, number];
type Circle = [Point, number];

let c: Circle = [[1, 2], 3];

// でも、こっちのほうがTypeScriptとしては適切よね
namespace alternative {
  class Point {
    constructor(public x: number, public y: number) {
    }
  }
  class Circle {
    constructor(public p: Point, public r: number) {
    }
  }
  let c2: Circle = new Circle(new Point(1, 2), 3);
  console.log(c2.p, c2.r);
}

export { Point, Circle, c, alternative }
</pre>
</div>
<p>こちらは素直にクラスでやればいいのに、という感じです。</p>
<p>type aliasは型に別名をつけるだけで、コンパイルされると消えてしまう存在です。そのため、リスト4.26のようなコードは書くことができません。</p>
<div class="caption-code">
<p class="caption">リスト4.26: type aliasは値を作らない</p>
<pre class="list language-ts">// 型の別名を作るだけで何かの値を作るわけではない…！
type StringArray = string[];

// なのでこういうことはできない
// error TS2304: Cannot find name 'StringArray'.
let strArray = new StringArray();
</pre>
</div>
<p>TypeScriptの仕様書にのっているtype aliasの利用例についてinterfaceでの書き換えができるものを示します（リスト4.27）。</p>
<div class="caption-code">
<p class="caption">リスト4.27: interfaceを使うんだ！</p>
<pre class="list language-ts">// これらはinterfaceで表現不可 type aliasで正解
type StringOrNumber = string | number;
type TextObject = string | { text: string };
type Coord = [number, number];
type ObjectStatics = typeof Object;
type Pair&lt;T&gt; = [T, T];
type Coordinates = Pair&lt;number&gt;;
type Tree&lt;T&gt; = T | { left: Tree&lt;T&gt;, right: Tree&lt;T&gt; };

// これらはinterfaceで表現可能
type HolidayLookup = Map&lt;string, Date&gt;;
interface AltHolidayLookup extends Map&lt;string, Date&gt; {
}

type Callback&lt;T&gt; = (data: T) =&gt; void;
interface AltCallback&lt;T&gt; {
  (date: T): void;
}

type RecFunc = () =&gt; RecFunc;
interface AltRecFunc {
  (): AltRecFunc;
}

export {
  StringOrNumber, TextObject, Coord, ObjectStatics, Pair,
  Coordinates, HolidayLookup, AltHolidayLookup, Callback, AltCallback,
}
</pre>
</div>
<p>union typesが絡むもの、tuple typesが絡むもの、型クエリが絡むものだけがinterfaceで置き換えることができません。</p>
<p>最後にtype aliasではなくインタフェースを使ったほうがいい理由を掲げておきます。</p>
<ul>
<li>interfaceのコンパイルエラーにはinterface名が表示されてわかりやすい<ul>
<li>type aliasは展開して表示されちゃうので無理</li>
</ul>
</li>
<li>interfaceは定義の統合ができるので後から自由に拡張できる<ul>
<li>type aliasは無理</li>
</ul>
</li>
</ul>
<p><strong>interfaceでできることをtype aliasでやるな！</strong></p>

<h2 id="polymorphic-this-type"><a id="h4-6"></a><span class="secno">4.6　</span>多態性のあるthis型（Polymorphic 'this' Type）</h2>
<p><code class="inline-code tt">this</code>を型として用いることができます。たとえばリスト4.28のようなコードです。</p>
<div class="caption-code">
<p class="caption">リスト4.28: thisを型として用いる</p>
<pre class="list language-ts">// 自分自身を型として表す時、this を利用する
class A {
  _this: this;
  a(): this {
    return this;
  }

  d(arg: this): this {
    return arg;
  }

  e() { // thisをreturnした場合暗黙的に返り値もthisとなる
    return this;
  }
}

class B extends A {
  b() {
    console.log(&quot;B&quot;);
  }
}

interface C extends A {
  c(): void;
}

// a() はクラスAのメソッドだが返り値の型はB自身だ！
new B().a().e().b();

// d() もクラスAのメソッドだが引数はBでなければならぬ
new B().d(new B()).b();

// d() はクラスAのメソッドだが、Bに生えている限りAを渡したら怒られてしまう
// error TS2345: Argument of type 'A' is not assignable to parameter of type 'B'.
//   Property 'b' is missing in type 'A'.
// new B().d(new A()).b();

// プロパティについても同様にB自身になる
new B()._this.b();

// インタフェースでもOK C自身になる
let c: C = null as any;
c.a().c();

export { }
</pre>
</div>
<p>thisを型として記述するという発想がすごいですね。引数や返り値の型としてthisを利用しています。fluentな、メソッドチェーンで使うAPIを組み立てる場合に役立ちそうです。</p>
<p>この書き方がないと、ジェネリクスなどを使ってごまかさなければならないところでしょう。とはいえ、便利になる代わりに仮引数に対して使ったりすると無駄に制約がきつくなったりする場合があるため、乱用は控えましょう。<code class="inline-code tt">return this;</code>を使った時に、メソッドの返り値が暗黙的に<code class="inline-code tt">this</code>になるのを利用する、くらいがよい塩梅かもしれません。</p>

<h2 id="specifying-this-types-for-functions"><a id="h4-7"></a><span class="secno">4.7　</span>関数のthisの型の指定（Specifying This Types For Functions）</h2>
<p>JavaScriptでは<code class="inline-code tt">Function.prototype.bind</code>や<code class="inline-code tt">Function.prototype.call</code>、<code class="inline-code tt">Function.prototype.apply</code>などの関数により、関数呼び出し時のthisの値の型を変更できます。この仕様は悪しき仕様だと筆者は思いますが、jQueryやDOMなど、古めのAPIではこの仕様をAPIとして組み込んだものが存在しています。TypeScriptではこの変更も頑張ってサポートしようとしています。</p>
<p>まずは簡単な例を見てみます（リスト4.29）。関数の1つ目の仮引数の名前を<code class="inline-code tt">this</code>にするだけです。</p>
<div class="caption-code">
<p class="caption">リスト4.29: thisの型を指定する</p>
<pre class="list language-ts">// 関数内部でのthisの型を偽の第一引数で指定
function testA(this: string) {
  console.log(this.toUpperCase());
}

// こういう利用を想定しているはず
// TYPESCRIPT と表示される
testA.bind(&quot;TypeScript&quot;)();

// 普通に呼び出すとエラーになる
// error TS2684: The 'this' context of type 'void'
//   is not assignable to method's 'this' of type 'string'.
// testA();

// 1つ目の仮引数がthisの型指定だった場合、それは偽物の仮引数
// 実際に何かを渡すとエラーになってしまう
// error TS2346: Supplied parameters do not match any signature of call target.
// testA(&quot;TypeScript&quot;);

function testB() {
  // --noImplicitThisオプション利用時、関数内でthisにアクセスすると怒られる
  // error TS2683: 'this' implicitly has type 'any'
  //   because it does not have a type annotation.
  // console.log(this.toUpperCase());
}

function testC(this: string, postfix: string) {
  console.log(`${this.toUpperCase()}${postfix}`);
}
// TYPESCRIPT! と表示される
testC.bind(&quot;TypeScript&quot;)(&quot;!&quot;);

export { testB }
</pre>
</div>
<p>thisの値がすり替えられるときの挙動に対応できています。<code class="inline-code tt">--noImplicitThis</code>オプションを利用すると、thisの型指定がない関数内でthisへアクセスするとエラーになります。thisを使わない限りはエラーにならないため、常用してしまってよいでしょう。</p>
<p>この仕様が現実世界でどう役に立つかを紹介します（リスト4.30）。</p>
<div class="caption-code">
<p class="caption">リスト4.30: thisの値が差し替えられるAPIに対応</p>
<pre class="list language-ts">// lib.dom.d.ts から抜粋
// listenerの仮引数の先頭が偽の仮引数で、thisの型の指定が行われている
interface HTMLBodyElement extends HTMLElement {
  addEventListener(
    type: &quot;click&quot;,
    listener: (this: this, ev: MouseEvent) =&gt; any,
    useCapture?: boolean): void;
  addEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    useCapture?: boolean): void;
}

let el1: HTMLBodyElement = null as any;
el1.addEventListener(&quot;click&quot;, function() {
  // thisの型はHTMLBodyElement
  this.innerText = &quot;Hi!&quot;;
});
el1.addEventListener(&quot;click&quot;, () =&gt; {
  // アロー関数の場合thisの値は変えられない
  // error TS2683: 'this' implicitly has type 'any'
  //   because it does not have a type annotation.
  // this.innerText = &quot;Hi!&quot;;
});

let el2: HTMLDivElement = null as any;
el2.addEventListener(&quot;click&quot;, function() {
  // thisの型はHTMLDivElement
  this.innerText = &quot;Hi!&quot;;
});

export { }
</pre>
</div>
<p>イベント発生時のコールバック関数でthisが差し替えられる場合に対応できています。自分でTypeScriptコードを書く時に必要になる場合は少なくありたいものです。しかし、型定義ファイルを作成する時にはお世話にならざるをえないときがあるでしょう。</p>

<h2 id="local-types"><a id="h4-8"></a><span class="secno">4.8　</span>ローカル型（Local Types）</h2>
<p>ローカル型は通常より小さい範囲で、クラスやインタフェースやenumやtype aliasを定義できます（リスト4.31）。</p>
<div class="caption-code">
<p class="caption">リスト4.31: ローカル型を試す</p>
<pre class="list language-ts">{
  type Data = string | number;
  let obj: Data = 1;

  console.log(obj);
}
{
  type Data = number | Date;
  let obj: Data = 1;

  console.log(obj);
}

// ブロックスコープの外ではもはやData型を参照することはできない
// error TS2304: Cannot find name 'Data'.
// let obj: Data;

{
  // クラス、enum、Buzzなども
  class Foo { }
  enum Bar {
    a,
    b,
  }
  interface Buzz { }

  console.log(Foo, Bar.a, null as any as Buzz); // 警告消し
}
// もちろんブロックスコープの外では上記3つは参照できない

export { }
</pre>
</div>
<p>使う機会は少ないかもしれませんが、リスト4.32のようにメソッドの中で簡易に別名を用意したい場合などに利用できるでしょう。</p>
<div class="caption-code">
<p class="caption">リスト4.32: メソッド内でだけ通用する別名</p>
<pre class="list language-ts">// 現実的な活用例
class Foo {
  method() {
    // メソッド内でのみ使えるtype alias！
    type Data = string | number;
    let obj: Data = 1;

    console.log(obj);
  }
}

export { Foo }
</pre>
</div>

<h2 id="type-queries"><a id="h4-9"></a><span class="secno">4.9　</span>型クエリ（Type Queries）</h2>
<p>型クエリは指定した変数（やメソッドなど）の型をコピーします。たとえば、リスト4.33のようなクラスそのものを型として指定したい場合、それ専用の書き方は用意されていません。そういうときに型クエリを使います。</p>
<div class="caption-code">
<p class="caption">リスト4.33: クラスそのものの型だよ！</p>
<pre class="list language-ts">class Sample {
  str: string;
}

// この書き方だとSampleのインスタンスになる Sampleクラスそのものではない
let obj: Sample;
// Sample自体の型をコピー！ つまりこれはSampleクラスそのものです
let clazz: typeof Sample;

// それぞれに当てはまる値は次のとおり なるほど
obj = new Sample();
clazz = Sample;

obj = new clazz();

// clazz を頑張って手で書くと次に等しい
let alterClazz: {
  new (): { str: string; };
};
alterClazz = clazz;
clazz = alterClazz;

export { }
</pre>
</div>
<p>メソッドなどの値も取れますが、thisを使うことはできないため、少しトリッキーなコードになる場合もあります。リスト4.34の例は、prototypeプロパティを使っているためJavaScript力が多少ないと思いつかないかもしれません。</p>
<div class="caption-code">
<p class="caption">リスト4.34: prototypeを参照するとメソッドの型が取れる</p>
<pre class="list language-ts">class Sample {
  hello = (word = &quot;TypeScript&quot;) =&gt; `Hello, ${word}`;
  bye: typeof Sample.prototype.hello;
}

let obj = new Sample();
obj.bye = obj.hello;

export { }
</pre>
</div>
<p>型クエリはわざわざインタフェースを定義するのもめんどくさいけど…というときに使える場合があります。リスト4.35では、ひとつ目の引数の型をふたつ目の引数や返り値の型にもコピーして使っています。</p>
<div class="caption-code">
<p class="caption">リスト4.35: ここまで複雑にするならインタフェース使って</p>
<pre class="list language-ts">// このコードは（死ぬほど読みにくいけど）正しい
function move(p1: { x1: number; y1: number; x2: number; y2: number; },
  p2: typeof p1,
): typeof p1 {
  return {
    x1: p1.x1 + p2.x1,
    y1: p1.y1 + p2.y1,
    x2: p1.x2 + p2.x2,
    y2: p1.y2 + p2.y2,
  };
}

let rect = move({
  x1: 1, y1: 1, // 無駄に多い
  x2: 2, y2: 2, // プロパティ
}, {
    x1: 3, y1: 3,
    x2: 4, y2: 4,
  });
rect.x1;
rect.x2;

export { }
</pre>
</div>
<p>ここまで来るとさすがに読みにくくなるのでインタフェースをひとつ定義したほうが断然いいですね。</p>

<h2 id="tuple-types"><a id="h4-10"></a><span class="secno">4.10　</span>タプル型（Tuple Types）</h2>
<p>tuple（タプル）は、任意の数の要素の組です。JavaScriptではtupleはサポートされていないため、TypeScriptでのtupleはただのArrayで表現されます。</p>
<p>既存のJavaScript資産を使おうとしたときに、配列の形で多値を返してくるライブラリが稀にあります。タプル型はそういったときに使うためのもので、TypeScriptでコードを書く際に多用するものではないでしょう。というのも、普通にコードを書いている限りでは型推論の結果としてタプル型が出てこないためです。</p>
<p>タプル型は型（TypeScript）の世界にしか登場せず、コンパイル後のJavaScriptコードでは消えてしまいます。記述方法は配列の型指定へ <code class="inline-code tt">[typeA, typeB]</code> のように配列の要素の代わりに型名を記述していくだけです。例を見てみましょう（リスト4.36）。</p>
<div class="caption-code">
<p class="caption">リスト4.36: 基本的な例</p>
<pre class="list language-ts">// まずは今までどおりの配列から
// これは別の箇所で解説している union typesで表現され (number | string | boolean)[]
let array = [1, &quot;str&quot;, true];

// {} は charAt を持たないので下記はコンパイルエラーになる
// array[1].charAt(0);

// tuple! 明示的な型の指定が必要
let tuple: [number, string, boolean] = [1, &quot;str&quot;, true];

// string は charAt を持つ！
tuple[1].charAt(0);

// TypeScriptのtuple typesは普通にArrayでもあるのだ
tuple.forEach(v =&gt; {
  console.log(v);
});

export { array }
</pre>
</div>
<p>各要素の型を指定すると、その要素のindexでアクセスしたときに適切な型で扱われます。</p>
<p>もちろん、タプル型はGenericsと組み合わせて利用できます（リスト4.37）。</p>
<div class="caption-code">
<p class="caption">リスト4.37: Genericsでの利用も可</p>
<pre class="list language-ts">// Genericsを使ってtupleを生成して返す
function zip&lt;T1, T2&gt;(v1: T1, v2: T2): [T1, T2] {
  return [v1, v2];
}

let tuple = zip(&quot;str&quot;, { hello(): string { return &quot;Hello!&quot;; } });
tuple[0].charAt(0); // おー、静的に検証される！
tuple[1].hello();   // おー、静的に検証される！

export { }
</pre>
</div>
<p>Good！いいですね。</p>
<p>さて、タプル型について重箱の隅をつついていきましょう。要素数が多すぎる場合、指定されていない値の型はunion typesになります。その例を見てみましょう（リスト4.38）。</p>
<div class="caption-code">
<p class="caption">リスト4.38: 値の要素数が多すぎる場合</p>
<pre class="list language-ts">// 要素が多い分にはOKだ！
let tuple: [string, number] = [&quot;str&quot;, 1, &quot;test&quot;];

// 範囲外の要素の型はすべての要素のunion、つまり string | number になる。
let value = tuple[2];

// 以下はダメ。true は string | number ではないため。
// tuple = [&quot;str&quot;, 1, true];
</pre>
</div>
<p>お次は要素の順序がズレた場合、どうなるかを見てみましょう（リスト4.39）。</p>
<div class="caption-code">
<p class="caption">リスト4.39: 絶望に身をよじれ…！</p>
<pre class="list language-ts">let tuple: [string, number] = [&quot;str&quot;, 1];

// 先頭をnumberに…
tuple.unshift(1);

// あぁっ！実行時エラー！
// Uncaught TypeError: undefined is not a function
tuple[0].charAt(0);

export { }
</pre>
</div>
<p>…悲しい結果になりました。<code class="inline-code tt">[1, true]</code>のような配列のリテラルをタプル型に推論しないのはおそらくこのためでしょう。</p>
<p>unshiftやpopなど、配列の要素を操作する方法は色々ありますが、後からprototypeを拡張することすら可能なJavaScriptではTypeScriptコンパイラ側ですべてをキャッチアップすることは不可能です。タプル型を扱う場合は要素数を変更するような操作をしないほうがよいでしょう。</p>
<p>なるべくなら、タプルは使いたくないですね。</p>

<h2 id="non-null-assertion-operator"><a id="h4-11"></a><span class="secno">4.11　</span>非null指定演算子（Non-null Assertion Operator）</h2>
<p>非null指定演算子（<code class="inline-code tt">!</code>）は、指定した値が<code class="inline-code tt">null</code>や<code class="inline-code tt">undefined</code>ではないことを人力でコンパイラに教えてやるための記法です。基本的に、この演算子は使わないにこしたことはありません。新規にコードを書き起こすのであれば非null指定演算子は使わないほうがよいでしょう。</p>
<p>しかしながら、昔からメンテしているTypeScriptコードについてはこの演算子に頼らざるをえない場合も多いです。<code class="inline-code tt">--strictNullChecks</code>オプションを有効にしたい場合、省略可能なプロパティではundefinedのチェックが必須になります。警告を低コストに抑制したい場合、非null指定演算子は有効な対処法となります。もちろん、将来的には徐々にリファクタリングしこの演算子の利用箇所を消滅させていくべきです。</p>
<p>例を見てみましょう（リスト4.40）。</p>
<div class="caption-code">
<p class="caption">リスト4.40: !演算子を使う</p>
<pre class="list language-ts">import * as fs from &quot;fs&quot;;

interface Config {
  filePath?: string | null;
  verbose?: boolean;
}

// 呼び出し元で値をしっかり代入していても...
let config: Config = {};
config.filePath = &quot;settings.json&quot;;
config.verbose = false;
processA(config);
function processA(config: Config = {}) {
  // 関数内部ではConfigのプロパティはundefinedの可能性が排除できない…
  // よって、! で無理やりエラーを消す必要がある
  if (fs.existsSync(config.filePath!)) {
    console.log(fs.readFileSync(config.filePath!, &quot;utf8&quot;));
  }
}

function processB(config: Config = {}) {
  // 関数内で初期値を設定してやるとエラーを解消できる（かしこい）
  config.filePath = config.filePath || &quot;settings.json&quot;;
  config.verbose = config.verbose || false;

  // 初期値設定済なので ! 不要
  if (fs.existsSync(config.filePath)) {
    console.log(fs.readFileSync(config.filePath, &quot;utf8&quot;));
  }

  // undefinedではなくした結果は関数をまたいで引き継がれない
  // 残念だが当然…
  processA(config);
}

// Configのundefinedとnull無し版
interface ConfigFixed {
  filePath: string;
  verbose: boolean;
}

function processC(config: Config = {}) {
  // ? 除去版に値を詰め替える
  const fixed: ConfigFixed = {
    filePath: config.filePath || &quot;settings.json&quot;,
    verbose: config.verbose || false,
  };

  if (fs.existsSync(fixed.filePath)) {
    console.log(fs.readFileSync(fixed.filePath, &quot;utf8&quot;));
  }
}

export { Config, processB, processC }
</pre>
</div>
<p>人間がundefinedやnullではないと確信できる場合、エラーとなる箇所の末尾に<code class="inline-code tt">!</code>をつけていきます。非null指定演算子をなるべく使わない手段として使う前に初期値を代入する、undefinedやnullを含まない型の値に詰め直すなどが考えられます。他の方法も見てみます（リスト4.41）。先に見たリスト4.40も併せ、undefined、nullフリーな型を用意して処理の途中からそちらに乗り換えるのが王道でしょうか。</p>
<div class="caption-code">
<p class="caption">リスト4.41: デフォルト値と付き合う</p>
<pre class="list language-ts">interface Config {
  filePath?: string | null;
  verbose?: boolean;
}

// Configのundefinedとnull無し版
interface ConfigFixed {
  filePath: string;
  verbose: boolean;
}

let config: Config = {
  verbose: true,
};
// filledの型は {} &amp; ConfigFixed &amp; Config
// assignの定義が引数4つまではintersection typesで定義されているため
// assign&lt;T, U, V&gt;(target: T, source1: U, source2: V): T &amp; U &amp; V; が実際の定義
let defaultConfig: ConfigFixed = { filePath: &quot;settings.json&quot;, verbose: false };
let filled = Object.assign({}, defaultConfig, config);

// ConfigとConfigFixedには直接の互換性はない！
// error TS2322: Type 'Config' is not assignable to type 'ConfigFixed'.
//   Types of property 'filePath' are incompatible.
//     Type 'string | undefined' is not assignable to type 'string'.
//       Type 'undefined' is not assignable to type 'string'.
// let fixed: ConfigFixed = config;

// filledはfilePathとverboseが存在することが確定しているのでConfigFixedと互換性がある！
let fixed: ConfigFixed = filled;
console.log(fixed);

export { ConfigFixed, fixed }
</pre>
</div>
<p>Control flow based type analysisが賢く処理してくれることに賭けるか、<code class="inline-code tt">Object.assign</code>などを使い、intersection typesを上手く活用します。</p>
<p>他によい方法が思いついたら、ぜひ筆者にその方法を教えてください。筆者としてはもう少しControl flow based type analysisと構造的部分型の相性がよいと楽だなと考え、TypeScriptリポジトリに<a href="https://github.com/Microsoft/TypeScript/issues/10065" class="link">Issue</a><a id="fnb-issue10065" href="#fn-issue10065" class="noteref" epub:type="noteref">*3</a>を立てています。もし興味があれば覗いてみて、何か意見を書いていってください。</p>
<div class="footnote" epub:type="footnote" id="fn-issue10065"><p class="footnote">[*3] <a href="https://github.com/Microsoft/TypeScript/issues/10065" class="link">https://github.com/Microsoft/TypeScript/issues/10065</a></p></div>
      </div>
      <nav class="book-navi book-prev">
                <a href="types-basic.html">
          <div class="book-cursor"><span class="cursor-prev">◀</span></div>
        </a>
              </nav>
      <nav class="book-navi book-next">
                <a href="tsc-options.html">
          <div class="book-cursor"><span class="cursor-next">▶</span></div>
        </a>
              </nav>
    </div>
  </div>
  <footer>
      </footer>
  </body>
</html>
